ESP32 Icon64 A2DP Flow Diagram
============================

1. System Initialization (setup())
   ├── Initialize GPIO pins (MODE_PIN)
   ├── Setup FastLED with WS2812B LEDs
   ├── Create queue for A2DP->FFT communication
   ├── Create FFT rendering task on Core 1
   └── Initialize A2DP sink
       ├── Set pin configuration
       ├── Start Bluetooth (device name: "bluelight2")
       ├── Set audio_data_callback as stream reader
       └── Set connection_state_changed callback

2. Main Loop (loop())
   └── Monitor audio state changes
       ├── If REMOTE_SUSPEND/STOPPED
       │   ├── If connected & played audio → Show PAUSE icon
       │   ├── If connected & no audio → Show BLE icon
       │   └── If not connected → Show HEART icon
       └── If STARTED
           └── Set devicePlayedAudio flag

3. Audio Processing Flow
   ├── audio_data_callback (Called when audio data arrives)
   │   ├── Check if FFT queue is empty
   │   ├── Process audio samples (L+R channels)
   │   └── Send to FFT queue
   │
   └── renderFFT (Running on Core 1)
       ├── Process FFT when queue has data
       ├── Apply windowing and FFT computation
       ├── Create frequency bands
       ├── Map frequencies to LED intensities
       └── Update LED display

4. Helper Functions
   ├── getLedIndex
   │   └── Maps x,y coordinates to LED strip index
   │
   ├── createBands
   │   └── Processes FFT data into frequency bands
   │
   └── drawIcon
       ├── Calculates breathing effect brightness
       └── Updates LED matrix with icon data

5. State Management
   ├── connection_state_changed
   │   └── Tracks Bluetooth connection state
   │
   └── Global State Variables
       ├── devicePlayedAudio
       ├── currentAudioState
       └── bleDeviceConnected



// BACKUP OF FANCY RIPPLES RENDERFFT NEW CODE IN CASE I MESS UP
// void renderFFT(void *parameter) {
//     static uint32_t lastFrame = 0;
//     const uint32_t frameTime = 1000 / 30;  // Target 30fps
    
//     while (true) {
//         uint32_t currentTime = millis();
//         if (currentTime - lastFrame < frameTime) {
//             delay(1);
//             continue;
//         }
//         lastFrame = currentTime;
        
//         // Create a black background
//         tft->fillScreen(BLACK);
        
//         // Update and draw ripple effects first
//         updateRipples();
        
//         // Draw LEDs on top of ripples
//         for (byte band = 0; band < NUM_BANDS; band++) {
//             intensity = map(peak[band], 1, amplitude, 0, NUM_ROWS);
            
//             for (int i = 0; i < NUM_ROWS; i++) {
//                 if (i >= intensity) {
//                     drawLED(band, NUM_ROWS - 1 - i, 0, 0, 0, false);
//                 } else {
//                     drawLED(band, NUM_ROWS - 1 - i, i * 16, 255, 255, true);
//                 }
//             }
//         }
//     }
// }
//  -- end of backup in case of kevyn making an oopsie like a silly boy



Cascade/Claude's great idea: ideas for improvement:

- Add a "mute" button to toggle audio playback
- Add a "play" button to start playback
- Add a "pause" button to pause playback
- Adding gaps between the blocks to make them look more like distinct LEDs
- Making the blocks round instead of square using fillCircle() instead of fillRect()
- Adding a "glow" effect by drawing a slightly larger, semi-transparent block behind each "LED"
- Using more bands (like 16 or 32) since we're not limited by physical LED count
- Adding visual effects like block borders or 3D-looking bevels
- Animating the transitions between intensity levels for smoother visualization
- Multiple visualization styles with mode switching:
  * Classic LED matrix
  * Flowing/liquid style
  * Shooting stars effect
  * Rainbow wave patterns
- Reactive backgrounds with:
  * Ripple effects that respond to bass frequencies (gravitational waves from sick beats!)
  * Particle effects behind the visualization
  * Color schemes that adapt to music intensity
- Performance optimizations:
  * Use DMA for faster display updates
  * Pre-calculate common patterns in PSRAM
  * Double buffering for smoother animations